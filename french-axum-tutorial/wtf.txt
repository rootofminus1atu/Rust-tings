use axum::{extract::Query, response::{Html, IntoResponse}, routing::get, Router};
use tracing::info;
use serde::Deserialize;

// old way:
// let addr = SocketAddr::from(([127, 0, 0, 1], 8080));
// println!("LISTENING ON {}", addr);
// axum::Server::bind(&addr)
//     .serve(routes_hello.into_make_service())
//     .await
//     .unwrap()


#[derive(Debug, Deserialize)]
struct HelloParams {
    name: Option<String>
}


async fn handler_hello2(Query(params): Query<HelloParams>) -> Html<String> {
    let name = params.name.as_deref().unwrap_or("world");

    Html(format!("Hello, <strong>{}</strong>", name))
}


#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();
    info!("tracing initialized");


    // let hello_routes = Router::new()
    //     .route("/", get(|| async { Html("Hello wooorld")}))
    //     .route("/2", get(handler_hello2));

    // let api_routes = Router::new()
    //     .nest("/hello", hello_routes);

    let router = Router::new()
        .route("/", get(handler_hello2));

    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();
    axum::serve(listener, router).await.unwrap();
}
